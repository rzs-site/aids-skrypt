\section{Sortowanie przez scalanie}

Sortowanie przez scalanie zostało opracowane
przez Johna von~Neumanna w~roku 1945~\cite{merge-sort-wiki}.
Jest jednym z~reprezentatywnych przykładów
algorytmów opartych o~metodę \emph{dziel i zwyciężaj}.

\subsection{Algorytm scalania}
Opiszemy tutaj algorytm scalania, który odpowiada 
za~frazę \emph{zwyciężaj} w~naszej metodzie.
Jest to algorytm, który nie~jest algorytmem w~miejscu,
to znaczy, potrzebuje osobnej pamięci, by~wykonać
scalanie.

\begin{algorithm}
    \label{alg:merge}
    \caption{Złączanie dwóch tablic}
    \begin{algorithmic}[1]
        \Require Array \( A[1 \isep n] \) 
        and~\( B[1 \isep m] \) are already sorted.
        \Ensure Returned array is already sorted
            and consists of~\( A \) and~\( B \).
        \Procedure{Merge}{$A[1 \isep n], B[1 \isep m]$}
            \State \textbf{let} \( i \gets 1, j \gets 1, k \gets 1 \)
            \State \textbf{let} \( C[1 \isep n + m] \) 
            \While{\( i \le n \wedge j \le m \)}
                \If{\( A[i] \le B[j]\)}
                    \State \( C[k] \gets A[i] \)
                    \State \( i \gets i + 1 \)
                    \State \( k \gets k + 1 \)
                \Else 
                    \State \( C[k] \gets A[j] \)
                    \State \( j \gets j + 1 \)
                    \State \( k \gets k + 1 \)
                \EndIf
            \EndWhile
            \While{\( i \le n \)}
                \State \( C[k] \gets A[i] \)
                \State \( i \gets i + 1 \)
                \State \( k \gets k + 1 \)
            \EndWhile
            \While{\( j \le m \)}
                \State \( C[k] \gets A[j] \)
                \State \( j \gets j + 1 \)
                \State \( k \gets k + 1 \)
            \EndWhile
            \State \textbf{return} \( C \)
        \EndProcedure%
    \end{algorithmic}
\end{algorithm}